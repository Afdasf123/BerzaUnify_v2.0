; ======================================================================================================================
; FILE:         sentry.ahk
; PROJECT:      BerzaUnify v2.0
; AUTHOR:       AutoHotkey Expert Programmer (Generated)
; DESCRIPTION:  An intelligent, trigger-based AutoHotkey v2 script.
;               This Sentry passively monitors the application's log file for a specific trigger phrase.
;               Upon detection, it scrapes the content of the user's currently active window
;               and saves it to 'conversation_memory.txt' for the AI orchestrator to use as context.
;
; USAGE:
; 1. Ensure you have AutoHotkey v2 installed (https://www.autohotkey.com/).
; 2. Place this script in the same root directory as the `app.py` and other project files.
; 3. Run the Python application and redirect its output to the log file.
;    Example command: `python app.py > app.log 2>&1`
; 4. Run this `sentry.ahk` script. It will run in the system tray.
; 5. When you trigger an execution in the web UI, this script will detect the log message
;    and automatically scrape the content from your active chat/editor window.
;
; IMPORTANT: You may need to configure the 'targetControl' variable in the ScrapeAndSave() function.
;            See the detailed comments inside that function for instructions using Window Spy.
; ======================================================================================================================

; ======================================================================================================================
; SCRIPT CONFIGURATION AND DIRECTIVES
; ======================================================================================================================

#Requires AutoHotkey v2.0            ; Ensures the script is run with the correct AHK version.
#SingleInstance Force                ; Ensures only one instance of the script can run at a time.
Persistent                           ; Keeps the script running until explicitly closed by the user.

; ======================================================================================================================
; GLOBAL CONSTANTS
; These can be modified if the project's file structure or trigger phrases change.
; ======================================================================================================================

global LOG_FILE := "app.log"                         ; The log file generated by the Python application.
global TRIGGER_PHRASE := "--- EXECUTION_TRIGGERED ---" ; The exact phrase to watch for in the log file.
global MEMORY_FILE := "conversation_memory.txt"      ; The output file where scraped content is saved.

; ======================================================================================================================
; INITIALIZATION (AUTO-EXECUTE SECTION)
; This code runs once when the script starts.
; ======================================================================================================================

; --- Setup a timer to periodically check the log file for new content ---
; The timer calls the CheckLogFile function every 500 milliseconds (half a second).
; This is a lightweight and efficient way to monitor file changes without constant disk access.
SetTimer(CheckLogFile, 500)

; --- Setup a custom tray menu for user interaction ---
A_TrayMenu.Delete() ; Clear the default menu items (Help, Window Spy, etc.)
A_TrayMenu.Add("BerzaUnify Sentry v2.0", (*) => "") ; Title item, disabled.
A_TrayMenu.Add() ; Add a separator line.
A_TrayMenu.Add("Scrape Active Window Manually", (*) => ScrapeAndSave()) ; For testing/manual capture.
A_TrayMenu.Add() ; Add a separator line.
A_TrayMenu.Add("Exit Sentry", (*) => ExitApp()) ; Allows the user to gracefully close the script.

TrayTip("Sentry Active", "Monitoring " . LOG_FILE . " for triggers")

; The script is now persistent and will wait for timer events or user actions.
Return

; ======================================================================================================================
; CORE FUNCTIONS
; ======================================================================================================================

/**
 * Checks the log file for new entries since the last check. If the trigger phrase is found,
 * it calls the scraping function.
 */
CheckLogFile() {
    ; 'static' ensures this variable retains its value between function calls.
    ; This is how we remember where we last stopped reading the file.
    static lastPos := 0
    local file_size

    ; If the log file doesn't exist yet (e.g., app hasn't started), do nothing.
    if !FileExist(LOG_FILE) {
        return
    }

    file_size := FileGetSize(LOG_FILE)

    ; If the file size has increased, it means new content has been added.
    if (file_size > lastPos) {
        ; Open the file in read mode with UTF-8 encoding.
        local file := FileOpen(LOG_FILE, "r", "UTF-8")
        if !IsObject(file) {
            ; Failed to open file, maybe it's locked. Try again next time.
            return
        }

        ; Move the file pointer to where we last stopped reading.
        file.Seek(lastPos)
        
        ; Read all the new content from the last position to the end.
        local newContent := file.Read()
        file.Close()

        ; Check if the new content contains our trigger phrase.
        if InStr(newContent, TRIGGER_PHRASE) {
            TrayTip("Sentry", "Trigger detected! Scraping active window...")
            ScrapeAndSave()
        }
        
        ; Update our position to the new end of the file.
        lastPos := file_size
    } else if (file_size < lastPos) {
        ; This condition handles cases where the log file was cleared or rotated.
        ; We reset our position to the beginning of the new file.
        lastPos := 0
    }
}

/**
 * Scrapes text from the currently active window's primary text control and saves it to a file.
 * This is the core action performed when the trigger is detected.
 */
ScrapeAndSave() {
    ; This new version uses the more reliable "brute force" method of
    ; activating the window and simulating Ctrl+A, Ctrl+C.

    ; 1. Backup the user's current clipboard to restore it later.
    local clipboard_backup := ClipboardAll
    Clipboard := "" ; Clear the clipboard to ensure ClipWait works correctly.

    ; 2. Get the active window's ID. We don't need a specific control.
    local activeWinID := WinExist("A")
    if !activeWinID {
        TrayTip("Sentry Warning", "No active window found to scrape.")
        return
    }
    
    local activeWinTitle := WinGetTitle("A")

    ; 3. Activate the window to ensure it's ready for keystrokes.
    WinActivate("ahk_id " . activeWinID)
    Sleep(200) ; A small, robust delay after activating.

    ; 4. Send the scrape commands (Select All -> Copy).
    SendInput("^a")
    Sleep(150)
    SendInput("^c")
    
    ; 5. Wait up to 2 seconds for the clipboard to be populated.
    if !ClipWait(2) {
        TrayTip("Sentry Error", "Failed to copy text from active window: " . activeWinTitle)
        Clipboard := clipboard_backup ; Restore clipboard on failure.
        return
    }

    ; 6. Write the captured text to the memory file.
    try {
        local file := FileOpen(MEMORY_FILE, "w", "UTF-8")
        file.Write(Clipboard)
        file.Close()
        TrayTip("Sentry Success", "Conversation memory updated from`n" . activeWinTitle)
    } catch as e {
        TrayTip("Sentry File Error", "Failed to write to " . MEMORY_FILE . ":`n" . e.Message)
    }

    ; 7. Restore the user's original clipboard content.
    Clipboard := clipboard_backup
}